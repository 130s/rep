REP: 102
Title: ROS Install Target
Version: $Revision: 4 $
Last-Modified: $Date: 2010-09-18 18:36:21 -0700 (Sat, 18 Sep 2010) $
Author: Brian Gerkey <gerkey@willowgarage.com>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 19-Sep-2010
Post-History: 19-Sep-2010

Abstract
========

This REP describes an 'install' target for ROS.  This proposal describes a
file/directory layout policy and extensions to the rosbuild API to support
installation.  It also notes some known and expected issues with installation,
particularly regarding updating existing code to support installation.

History
=======

To date, there has been no 'make install' for ROS code.  The ROS
build system and associated tools were designed to support building in and
running from a packages source tree.  This design works well in
research-like environments, where everybody has his or her own copy of
the code checked out from version control.  But it is not appropriate for
providing system installations of ROS, e.g., as Debian packages (.debs).
The current best practice for such installations is to recursively copy
from a built package source tree, combined with heuristic filtering and
rpath-rewriting.

Goals
=====

The overall goal of install target is to allow for the installation of
ROS code.  More specifically, the install target should:

- install only what is needed at runtime;
- not rely on RPATH or RUNPATH settings;
- conform to accepted filesystem layouts (e.g., the Filesystem Heirarchy
  Standard [#fhs]_)
- provide developers with sufficient control over what is installed
  and where it goes;
- simplify common installation tasks; and
- have minimal impact on the ROS codebase.

To understand the implications of these specific goals, we'll take a couple
of strawman examples:

- A very simple installation method is to recursively copy everything from a 
  package source tree.  This method is disqualified because it is not
  minimal, and does not resolve the use of RPATH.
- One installation method is do away with the ROS package tree, putting
  the various pieces of each package into the best-fit locations in the
  system directory hierarchy: put libraries in /usr/lib, 
  executables in /usr/bin, .launch/.urdf/.mesh files in /usr/share,
  Python modules in /usr/lib/site-packages, etc.  This method is
  disqualified because a great deal of ROS code relies on the package
  tree to find and refer to resources in a package-relative manner;
  getting rid of the package tree would be hugely disruptive.

The install prefix: ROS_INSTALL_PREFIX
======================================

Installation is done relative to a prefix, ROS_INSTALL_PREFIX, which is
an absolute path.  The prefix is specified externally (e.g., by the user
doing the install, or by a packaging tool like pbuilder).  For system
installs, ROS_INSTALL_PREFIX is often /usr, sometimes /usr/local.
For a non-system install, it might be anything.

Reference implementation
========================

An implementation is in progress at
https://code.ros.org/svn/ros/stacks/ros/branches/install_target .  That
installation...

The stack is the installation unit
==================================

In ROS code, the stack is the installation unit; it is at the stack level
that we make releases, check versions, create binary packages, etc.  So
the install target also works at a stack level.  To install a stack:

::

  roscd <stack>
  make install

The install target is not supported at the level of an individual package.

Filesystem layout
=================

The overall layout is:

::

  ROS_INSTALL_PREFIX/
    bin/          : "important" executables, such as rospack and rostopic
    lib/          : all C/C++ shared and static libraries from all packages
      ros/        : the ROS package tree, grouped into stacks
      ros/ros     : the ros stack; ROS_ROOT points here
      ros/<stack> : other stacks are siblings to the ros stack

So a package 'foo', contained in a stack 'bar', can be found at
ROS_INSTALL_PREFIX/lib/ros/bar/foo.  And ROS_ROOT is always
ROS_INSTALL_PREFIX/lib/ros/ros.

Within a package, the layout is:

::

  ROS_INSTALL_PREFIX/lib/ros/<stack>/<package>/
    bin/ : C/C++ executables

Other package content can be organized in whatever way is convenient.


RPATH handling
==============

So that executables can be used from a package source tree, rosbuild
makes extensive use of RPATH entries.  These entries are added at link
time, and constitute paths to be searched at runtime for libraries that
are needed by the executable.  Reliance on RPATHS is unusual, brittle
(e.g., a built ROS tree can't be moved and reused without cleaning and
rebuilding), and discouraged by distribution maintainers (e.g., Debian's
stance [#debrpath]_, which is probably inherited by Ubuntu).

The proposed install target will strip RPATH entries from all
executables (including shared libraries).  This is done via CMake's
support for modifying RPATH during installation [#cmakerpath]_.  Because all
libraries are installed into ROS_INSTALL_PREFIX/lib, the installed
RPATH-less executables can be used so long as ROS_INSTALL_PREFIX/lib
is in the dynamic linker's search path.  For a system install, where
ROS_INSTALL_PREFIX is something like /usr, ROS_INSTALL_PREFIX/lib is in
the standard search path.  For a custom install, the user might need to
add ROS_INSTALL_PREFIX/lib to LD_LIBRARY_PATH (or equivalent).


rosbuild API
============

The macros below will be added to rosbuild.  These macros can be called
from a package's CMakeLists.txt file.

- rosbuild_install_executable(exe [INSTALL_TO_ROOT]) : Install the
  C/C++ executable exe, stripped of RPATH entries, to the bin subdirectory
  of the package (i.e., ROS_INSTALL_PREFIX/lib/ros/<stack>/<package>/bin).
  If the INSTALL_TO_ROOT option is given, the executable is instead
  installed to ROS_INSTALL_PREFIX/bin; this option is intended only for
  "important" executables, such as rospack and rostopic.
- rosbuild_install_library(lib [INSTALL_TO_PACKAGE]): Install the C/C++
  library lib, stripped of RPATH entries, to ROS_INSTALL_PREFIX/lib.
  If the INSTALL_TO_PACKAGE option is given, then the library is
  instead installed to the lib subdirectory of the package (i.e.,
  ROS_INSTALL_PREFIX/lib/ros/<stack>/<package>/lib); use of this option
  is discouraged, as it puts the library in a non-standard place.
- rosbuild_install_files(files...)
- rosbuild_install_programs(programs...)
- rosbuild_install_directory(dir)


Updating existing packages: the right way
=========================================

Updating existing packages: the INSTALL_EVERYTHING option
===============================================================

Non-rosbuild-controlled packages
================================

Known / open issues
===================

References
==========

.. [#fhs] Filesystem Heirarchy Standard
   (http://www.pathname.com/fhs/)

.. [#debrpath] Debian wiki: RPATH issue
   (http://wiki.debian.org/RpathIssue)

.. [#cmakerpath] CMake RPATH handling
   (http://www.vtk.org/Wiki/CMake_RPATH_handling)
   
Copyright
=========

This document has been placed in the public domain.


..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
