REP: 122
Title: Filesystem Hierarchy Standard layout changes for ROS
Version: $Revision$
Last-Modified: $Date$
Author: Ken Conley, Troy Straszheim, Morten Kjaergaard, Ethan Rublee, Tully Foote, Brian Gerkey
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 8-Feb-2012
ROS-Version: Fuerte
Post-History: 8-Feb-2012, 17-Feb-2012

Abstract
========

This REP introduces a new Filesystem Hierarchy Standard (FHS) [1]_
based layout for ROS and discusses the implications and changes
necessary for ROS code that is converted to this standard.

For ROS distributions, such as ROS Fuerte, this layout is created
within an install prefix, but this specification is intended to make
non-prefixed installs possible as well.

This REP is a work in progress.  The "`Future Work`_" section indicates
unfinished portions of this specification that will be resolved before
this REP is final.  The goal is to resolve these issues entirely by
the ROS Groovy release.

The majority of this specification is due to the hard work of Troy
Straszheim and Morten Kjaergaard on the catkin build system, which is
the reference implementation this REP is based on.  This REP does not
document catkin itself as the specification is intended to be
implementation-neutral.


Specification
=============

This specification defines changes to the filesystem layout,
associated environment variable updates, and necessary modifications
to ROS itself.

For the most part, this specification avoids a specific reliance on
the catkin build system, except for a new manifest tag to mark
packages as being built by catkin.  Additionally, this specification
does not define catkin-specific additions, such as
``CMAKE_PREFIX_PATH``, ``etc/catkin`` and ``etc/langs``.


Filesystem layout
'''''''''''''''''

Install prefix
--------------

For clarity, the install prefix is referred to as
``/opt/ros/<distro>``. The install prefix does not have to follow this
actual pattern, but it is the convention for ROS binary distributions.

The intent of this layout is to enable installations within the
standard ``/usr`` hierarchy.

Directory layout
----------------

The layout within the ``/opt/ros/<distro>`` install prefix is::

    bin/
    etc/
    include/
    lib/
    stacks/


This layout generally follows FHS conventions, with the addition of
the ``stacks`` directory for legacy (backwards-compatible) installs.
It also contains setup files to easily configure environment variables
for this prefix.

These directories are described in greater detail below.

NOTE: The ROS Fuerte release includes an additional ``share/``
directory, which is currently used as a transition mechanism for
resources and tools that require the ``ROS_PACKAGE_PATH``.  This is
described in the "`Future Work`_" section.


bin/
----

``bin`` is used to store top-level executables, i.e. executables that
are on ``PATH``.  This location replaces the old ``ROS_ROOT/bin``
location that stored ROS binaries, like ``rostopic`` and ``rospack``.

ROS stacks that are converted to use this new layout may install into
``bin``, but should do so sparingly as it adds to the user's ``PATH``.
Developers should also be careful about top-level executables and name
collisions.  In general, try to name executables so that the origin of
the executable is obvious, e.g. the same as the ROS package name.

In the case of a special install prefix, ``PATH`` must include this
location, e.g.::

    PATH=/opt/ros/<distro>/bin

etc/
----

This location is used to install global configuration files for a
particular ROS distribution.  Within the context of ROS, we introduce
``etc/ros``, which is where ROS-specific system configuration files
are stored.

Additionally, there is an ``etc/catkin`` and ``etc/langs`` that are
used by the underlying catkin build system.  Although ``etc/langs``
configures the active ROS message generators, it's implementation is
specific to message generation using catkin, and thus not specified
here.


include/
--------

ROS packages using the new install layout must install all header
files to the ``include`` directory.  Assuming a ROS package uses the
namespace ``<ros-package-name>``, include files for a package are
stored in::

    include/<ros-package-name>/

The specific include directories for a package are located using
``pkg-config`` or CMake ``find_package()``.


lib/
----

ROS packages using the new install layout must install library files
to the ``lib`` directory.

Python modules are installed to ``lib/pythonX.Y``, where ``X.Y`` is
the Python version.  This directory follows the standard Python
specification for the target platform.  Thus, it may be
``lib/pythonX.Y/dist-packages`` or ``lib/pythonX.Y/site-packages`` or
otherwise.

In the case of a speical install prefix, ``PKG_CONFIG_PATH`` must be
set to enable locating libraries and include directories using
``pkg-config``.  ``LD_LIBRARY_PATH`` must be also set so that
executables can load shared libraries.  We use the settings::

    PKG_CONFIG_PATH=/opt/ros/<distro>/lib/pkgconfig::$PKG_CONFIG_PATH
    LD_LIBRARY_PATH=/opt/ros/<distro>/lib:$LD_LIBRARY_PATH

``PYTHONPATH`` must also be set in a special install prefix and is
platform dependent.  For example, on Ubuntu Lucid with Python 2.6, the
setting is::

    PYTHONPATH=/opt/ros/<distro>/python2.6/dist-packages:$PYTHONPATH


stacks/
-------

``stacks`` is the installation location for legacy, rosmake-based
stacks.  It is included on the ``ROS_PACKAGE_PATH``, but has lower
precedence than stacks following the REP 122 layout.


Environment variables
'''''''''''''''''''''

``ROS_ROOT``
------------

For backwards-compatibility with rosmake-based build files,
``ROS_ROOT`` must exist within the new layout. However, its scope has
been narrowed to "backwards compatibility for finding legacy
``rosbuild`` and ``mk`` resources." Other uses, such as finding ROS
binaries, are no longer supported.  Thus, ``ROS_ROOT`` is deprecated,
though there are no plans to remove it.

For a full specification and rationale, see REP 123 [9]_, which also
proposes new ROS filesystem environment variables based on the REP 122
layout.


Changes to ROS
''''''''''''''

``<catkin/>`` tag in manifest
-----------------------------

Package manifests [3]_ can now contain a ``<catkin/>`` tag to indicate
that they are built using the catkin build system.  This tag is a
performance optimization for tools like ``rosmake`` and the Python
``roslib.load_manifest()`` API.  It is not required, but it is
*strongly recommended*.

PYTHONPATH, roslib.load_manifest()
----------------------------------

Python modules now install into a ``dist-packages``/``site-packages``
in the ``lib`` directory in the install prefix.  This installation
uses the standard Python distutil/setuptools toolchain.

The Python install directory is added to the ``PYTHONPATH``.  Thus,
these modules are immediately accessible via Python ``import`` and do
not require a ``roslib.load_manifest()``.

In order to prevent unnecessary accumulation to the Python
``sys.path``, ``roslib.load_manifest()`` does not recurse through
packages that have a ``<catkin/>`` tag in their manifest.

Python modules and scripts that are part of the FHS install layout
*must not* use ``load_manifest`` as it does not work properly within
an out-of-source build.

Stack version may now be in stack.yaml
--------------------------------------

Catkin defines a ``stack.yaml`` file for release packaging that
contains a version number.  In order to not violate DRY (Don't Repeat
Yourself) principles, tools like ``rosversion`` are now capable of
locating the version number defined in this file.  This REP amends REP
109 [4]_ to specify that the version number in the ``stack.yaml`` has the
highest precedence.

Motivation
==========

The ROS Fuerte release migrates many of the low-level libraries to use
a standard Filesystem Hiearchy Standard-like layout [2]_ contained in
a ROS-distribution-specific install prefix
(e.g. ``/opt/ros/fuerte/``). The goals of this conversion are many:

- Make ROS libraries more "normal"

- Enable the ROS toolchain to use existing libraries for packaging
  and release (e.g. ``git-buildpackage``)

- Enable ROS messages, libraries and tools to be easily integrated
  with other build systems via ``pkg-config`` and CMake's
  ``find_package()``.

- Enable ROS binary releases to be accepted into Debian, Ubuntu, and
  other Linux distributions.
   
- Preserve the ability to install multiple ROS distributions on the
  same machine.

- Eventually eliminate the need for ROS-specific filesystem
  environment variables when the installation is a standard prefix,
  i.e. ``/usr``.


The final goal should be possible with converted stacks, but has not
yet been verified.  There are also unresolved issues with
package-relative resources, which is described in the "`Future Work`_"
section.  The focus on the implementation has been preserving the
ability to install multiple ROS distributions on the same machine as
robots frequently are shared, expensive resources.

Compatibility with the Filesystem Hiearchy Standard has been a
long-term goal for ROS.  ROS began as an in-source, package-relative
system for finding, developing, building, and distributing code.
Multiple attempts have been made to transition towards an
FHS-compatible layout for ROS, including the withdrawn REP 102 [5]_
and a prototype "rosbuild2" system that was deployed in ROS Electric.
Experiences with those previous efforts have enabled us to accomplish
this goal with minimal compatibility issues.

One major goal these changes have enabled is much better integration
with PCL.  The standalone version of PCL can now build against the
required ROS messages using CMake with minimal additional
dependencies.  Hopefully, many more libraries will be able to
transition to standalone implementations.


Rationale
=========

The rationale for using the Filesystem Hierarchy Standard is simple:
it is the only solution for making the system more "normal".  Most of
the specifications in this REP are straightforward translations of
that standard.


Backwards Compatibility
=======================

/opt/ros/<distro>/stacks
''''''''''''''''''''''''

There are no known regressions related to the new layout for building
legacy (rosmake-based) stacks that are specifically related to this
specification.  We have been able to build legacy stacks on top of the
REP 122-compliant stacks by using the ROS manifest "export" mechanism
with the output of ``pkg-config``.  No changes were necessary to the
rosmake toolchain based on this REP.  Legacy stacks still use the same
installation procedure as before.

We have put together a migration guide [6]_ that generally notes
issues with increased link/include strictness that are separate from
this REP.

rosmake
'''''''

rosmake will recurse into packages that are installed in ``share``.
As this location does not contain ``Makefile`` files, it will treat
this as not buildable.  For small performance improvements, new-style
packages with a ``<catkin>`` tag in their manifest.xml are treated the
same as ``ROS_NOBUILD``.

roslaunch remote, <machine> tag incompatibility
'''''''''''''''''''''''''''''''''''''''''''''''

The changes in this specification break compatibility with roslaunch
remote launches as the environment configuration is very different.
The non-backwards-compatible changes required in roslaunch are
specified separately in REP 124 [7]_.

ROS_ROOT
''''''''

As described in the specification, ``ROS_ROOT`` preserves
backwards-compatibility for ``mk`` and ``rosbuild`` files.  For
example,::

    include($ENV{ROS_ROOT}/core/rosbuild/rosbuild.cmake)

resolves to the same path.

roslib.load_manifest()
''''''''''''''''''''''

The Python environment bootstrapper, ``roslib.load_manifest()``, is
safe to use in rosmake-based packages.  However, it is also
unnecessary for importing Python modules that use the FHS install
layout.

As noted in the specification, ``roslib.load_manifest()`` cannot be
used in converted stacks.


rosinstall
''''''''''

Changes to both ``ROS_ROOT`` and environment setup have created
incompatibilities with the rosinstall tool.  There are also separate
issues with rosinstall and catkin compatibility when building
completely from source that are separate from the issues of install
layout changes.  All of these are resolveable and are being addressed
outside the scope of this REP.


Reference implementation
========================

A reference implementation is provided by the catkin build system,
which is deployed in the ROS Fuerte release.  Where possible, changes
to this REP will be incorporated in the ROS Fuerte release.
Otherwise, changes will be incorporated in future ROS releases.

The "`Future Work`_" section notes issues with the ROS Fuerte
reference implementation.


Future work
===========

ROS Fuerte currently uses ``share`` to install ROS manifest and
package-relative resources.  This includes package-relative binaries,
which are not allowed by FHS standards as it is intended for
"read-only architecture independent data files" [8]_.

In ROS Fuerte, ``ROS_PACKAGE_PATH`` is defined as:

    ROS_PACKAGE_PATH=/opt/ros/<distro>/share:/opt/ros/<distro>/stacks

``ROS_ROOT`` is defined to be::

    ROS_ROOT=/opt/ros/<distro>/share/ros

All package-relative assets are explicitly installed to
``share/<ros-package-name>``.  These assets include:

- manifest files (``manifest.xml``)
- launch files
- package-relative-executables (both binary and script)
- bag files used in a package-relative manner

Similarly, stack manifests (``stack.xml``) are explicitly installed to
``share/<ros-stack-name>``.

Issues with this layout and proposed resolutions are discussed below.

Performance issues with share
'''''''''''''''''''''''''''''

All directories in ``share/`` will be traversed by tools like
``rospack`` and ``rosstack``.  This is efficient if all
sub-directories are ROS aware, but will deteriorate greatly if the
presence of deep, non-ROS aware directories.

There are multiple ways to address the performance issue by updating
the ROS package and stack specification.  For example, a lookup table
could be used instead for installed packages.  Package-relative
computations could also be made much more simple as the location
relative to ``share`` is fixed.

It is hoped that more experience with this new layout will provide
better intuition on how to resolve the above issues.


Package contents
''''''''''''''''

The ``share/`` does not preserve the full contents of ROS packages
within the installed layout.  This affects package-relative workflows,
like using``rosed`` to quickly view header file information.  There
are two categories of contents no longer locatable by package-relative
tools:

 1. Resources that are installed in a different location (e.g. C++
    header files in ``include``)
 2. Sources resources (e.g. C++ ``.cpp files``) that are no longer
    installed due to explicit installation targets.

Thibault Kruse noted that approaches like `stow`_ could reproduce this
information.  Stow creates a directory for a package, plus symlinks
within that directory to all the install resources of that package.
It would be desireable to provide this functionality separately so
that the base installation is FHS-compliant.

.. _stow: http://www.gnu.org/software/stow/

Stack contents, roscreate-stack
'''''''''''''''''''''''''''''''

The ``share/`` layout does not preserve the stack-package
relationship: it is no longer possible to determine the packages that
a stack contains in the install layout.

To the best of our knowledge, the only tool directly affected by this
is ``roscreate-stack``.  Although this is a convenient tool, it has
less utility moving forward, so we made the difficult decision to
delete it.

An alternative would be to preserve the hierachy by using::

    share/<stack-name>/<package-name>

This layout makes the path to ``<package-name>`` unstable.  ROS
packages frequently change stacks, so a package-relative resource
would frequently move locations in ``share`` between releases.  As we
eventually wish for package-relative resources to be easily located
without ROS-specific toolchain such as ``rospack``, this alternative
was rejected.  We also wish to avoid ROS packages having to know their
stack.

There other other alternatives, such as creating index files that
contain this information, but they are currently not being pursued as
preserving ``roscreate-stack`` was not a strong enough use case.  The
implementation of the new build system leverages the fact that all
converted ROS stacks are normal system dependencies, e.g., a
dependency on "boost" is no different than a dependency on
"ros_comm". These system system dependencies are resolved using tools
like rosdep.  This transition requires that *stack* dependencies on
converted stacks be migrated to be *rosdep* dependencies instead.

In other words, preserving the ``roscreate-stack`` tool would
implement the wrong behavior for converted stacks: it would treat them
as ROS stack dependencies, instead of system dependencies.

lib/ layout alternative
'''''''''''''''''''''''

An alternative to ``lib`` was suggested by Jack O'Quin:

    There is no obvious choice for an alternative. Although ``/lib``
    mostly contains libraries, there are actually quite a few
    executables in its subdirectories, and many more under
    ``/usr/lib``. So, I suggest something like
    ``lib/ros/<ros-package-name>`` in place of
    ``share/<ros-package-name>``. Another alternative might be ``opt``
    (or just making something up), but ``lib`` seems better to me.
    
Bill Morris also noted that FreeBSD uses ``/usr/libexec`` to store
non-PATH binaries, which addresses the ontological conflict of storing
executables in a "lib" directory.  Unfortunately, ``libexec`` is not
FHS compliant, as noted in this ``debian-devel`` `thread`_:

.. _thread: http://lists.debian.org/debian-devel/2005/05/msg00401.html

``lib/ros/<ros-package-name>`` is the leading candidate for replacing
the ``share/`` layout.  The simplest implementation would simply
replace "share" with "lib/ros", which would end up placing manifest
and launch files resources within the lib tree.  This is similar to
layouts like Python's ``lib/pythonX.Y/site-packages``, which includes
egg manifest and data files.


References
==========

.. [1] Wikipedia: Filesystem Hiearchy Standard
   (http://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard)
.. [2] ROS filesystem environment variables
   (http://ros.org/doc/api/rospkg/html/environment.html) 
.. [3] ROS Manifest XML Tags Reference
   (http://www.ros.org/doc/api/rospkg/html/manifest_xml.html)
.. [4] REP 109: Unary Stacks
   (http://ros.org/reps/rep-0109.html)
.. [5] REP 102: ROS Install Target
   (http://ros.org/reps/rep-0102.html) 
.. [6] ROS Fuerte Migration Guide
   (http://ros.org/wiki/fuerte/Migration)
.. [7] REP 124: Changes to roslaunch and rosrun for REP 122 and catkin build system
   (http://ros.org/reps/rep-0124.html)
.. [8] Filesystem Hierarchy Standard 2.3
   (http://www.pathname.com/fhs/pub/fhs-2.3.pdf)
.. [9] REP 123: ROS_ETC_DIR, ROS_DISTRO environment variables and ROS_ROOT changes
   (http://ros.org/reps/rep-0123.html) 

Copyright
=========

This document has been placed in the public domain.



..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:

