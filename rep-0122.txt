REP: 122
Title: Filesystem Hierarchy Standard layout changes for ROS
Version: $Revision: 1 $
Last-Modified: $Date: 2012-02-06 13:00:00 +0200 (Mon, 6 Feb 2012) $
Author: Ken Conley
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 6-Feb-2012
ROS-Version: Fuerte
Post-History: 6-Feb-2012

Abstract
========

This REP introduces a new Filesystem Hierarchy Standard (FHS) [1]_
layout for ROS and discusses the implications and changes necessary
for ROS code that is converted to this standard.  

For ROS distributions, such as ROS Fuerte, this layout is created
within an install prefix, but this specification is intended to make
non-prefixed installs possible as well.

This REP makes reference to the catkin build system, which is used as
our reference implementation. However, this REP does not provide
catkin-specific documentation an is intended to mostly be neutral to
implementation. 


Specification
=============

This specification defines changes to the filesystem layout,
associated environment variable changes, as well as changes necessary
within the ROS toolchain.

For the most part, this specification avoids a specific reliance on
the catkin build system except for:

 - locating binary executables in a catkin build workspace
 - a new manifest tag to mark packages as being built by catkin

Additionally, this specification does not define catkin-specific
additions, such as modifications to ``CMAKE_PREFIX_PATH`` and
``etc/catkin``.


Filesystem layout
'''''''''''''''''

Install prefix
--------------

For clarity, the install prefix is referred to as
``/opt/ros/<distro>``. The install prefix does not have to follow this
actual pattern, but it is the convention that ROS binary distributions
follow.

The intent of this layout is to enable installations with no install
prefix whatsoever, though this is not possible at the time of this
REP.

Directory layout
----------------

The new /opt/ros/<distro> layout::

    bin/
    etc/
    include/
    lib/
    share/
    stacks/


This layout generally follows FHS conventions, with the addition of
the ``stacks`` directory for legacy (backwards-compatible) installs.

For backwards-compatibility, existing packages and stacks use the
following pattern::

    share/<ros-stack-name>/stack.xml
    share/<ros-package-name>/manifest.xml

Stacks should *never* install to both ``share`` and ``stacks``.
Stacks following this specification install to ``share``.  Legacy
(rosmake-based) stacks install to ``stacks``.

These directories are described in greater detail below.


bin/
----

``bin`` is used to store top-level executables, i.e. executables that
are on ``PATH``.  This location replaces the old ``ROS_ROOT/bin``
location that stored ROS binaries, like ``rostopic`` and ``rospack``.

ROS stacks that are converted to use this new layout may install into
``bin``, but should do so sparingly as it adds to the user's ``PATH``.
Developers should also be careful about top-level executables and name
collisions.  In general, try to name executables so that the origin of
the executable is obvious, e.g. the same as the ROS package name.

In the case of an install prefix, ``PATH`` must include this location, e.g.::

    PATH=/opt/ros/<distro>/bin

etc/
----

This location is used to install global configuration files for a
particular ROS distribution.  Within the context of ROS, we introduce
``etc/ros``, which is where ROS-specific system configuration files
are stored.

Additionally, there is an ``etc/catkin`` and ``etc/langs`` that are
used by the underlying catkin build system.  Although ``etc/langs``
configures the active ROS message generators, it's implementation is
specific to message generation using catkin, and thus not specified
here.


include/
--------

ROS packages using the new install layout must install all header
files to the ``include`` directory.  Assuming a ROS package uses the
namespace ``<ros-package-name>``, include files for a package are
stored in::

    include/<ros-package-name>/

The specific include directories for a package are located using
``pkg-config`` or CMake ``find_package()``.


lib/
----

ROS packages using the new install layout must install all header
files to the ``lib`` directory.  

Python modules are installed ``lib/pythonX.Y``, where ``X.Y`` is the
Python version.  This directory follows the standard Python
specification for the target platform.  Thus, it may be
``lib/pythonX.Y/dist-packages`` or ``lib/pythonX.Y/site-packages`` or
otherwise.

In the case of an install prefix, ``PKG_CONFIG_PATH`` must be set to
enable locating libraries and include directories using
``pkg-config``.  ``LD_LIBRARY_PATH`` must be also set so that
executables can load shared libraries.  We use the settings::

    PKG_CONFIG_PATH=/opt/ros/<distro>/lib/pkgconfig::$PKG_CONFIG_PATH
    LD_LIBRARY_PATH=/opt/ros/<distro>/lib:$LD_LIBRARY_PATH

``PYTHONPATH`` must also be set in an install prefix as is platform
dependent.  For example, on Ubuntu Lucid with Python 2.6, the setting
is::

    PYTHONPATH=/opt/ros/<distro>/python2.6/dist-packages:$PYTHONPATH


share/
------

``share`` is the root of the ``ROS_PACKAGE_PATH``

All package-relative assets must be explicitly installed to
``share/<ros-package-name>``.  These assets include:

 * manifest files (``manifest.xml`` and ``stack.xml``)
 * launch files
 * package-relative-executables (both binary and script)
 * bag files used in a package-relative manner
 * rosdep definitions (``rosdep.yaml``)  (See note below)

By convention, binary executables go in
``share/<ros-package-name>/bin`` and script executables go in
``share/<ros-package-name/scripts``.  This convention is not enforced.

NOTE: rosdep is currently being redesigned to make stack-relative
``rosdep.yaml`` files unnecessary.  ``rosdep.yaml`` files are expected
to disappear from the ``share`` directory once this new functionality
is available.


stacks/
-------

``stacks`` is installation location for legacy, rosmake-based stacks.
It is included on the ``ROS_PACKAGE_PATH``, but has lower precedence
than ``share``.


Environment variables
'''''''''''''''''''''

``ROS_ROOT``
------------

``ROS_ROOT`` is defined to be::

    ROS_ROOT=/opt/ros/<distro>/share/ros

The *only* purpose of ``ROS_ROOT`` is backwards compatibility for
finding legacy ``rosbuild`` and ``mk`` resources.  It no longer
contains ROS binaries nor any other ROS stack assets.


``ROS_PACKAGE_PATH``
--------------------

``ROS_PACKAGE_PATH`` is defined to be::

    ROS_PACKAGE_PATH=/opt/ros/<distro>/share:/opt/ros/<distro>/stacks

Thus, ``share/`` has precedence over ``stacks/``.  

Packages and stacks are responsible for explicitly installing
``manifest.xml`` and ``stack.xml`` files in
``share/<package-or-stack-name>``.

Changes to ROS
''''''''''''''

The following sections describe the effects on and updates to the ROS
package-relative specification for the new FHS layout.  They also
discuss changes to Python library loading and a minor change to the
ROS package manifest format.


Locating package-relative executables in the install tree
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Package-relative executables are files specified with
``(<ros-package-name>, <file-name>)``, where ``<file-name>`` denotes a
file with executable permissions located anywhere in the directory
root of ``<ros-package-name>``.

Following the specification for ``share/``, package-relative
executables are stored in ``share/ros-package-name/bin/executable``.
In an install tree, ``ROS_PACKAGE_PATH`` includes the ``share/`` path.
Thus, there are no updates to the package-relative executable
specification for an install tree.


Locating package-relative executables in CATKIN_BINARY_DIR
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

We amend the package-relative specification for the
catkin-based binary builds, which builds out-of-source binaries
outside of the ROS source package tree.

In order to find executables generated to a catkin-based build
directory, tools must example the
``$CATKIN_BINARY_DIR/etc/packages.list`` file for

``packages.list`` is a text file, where each line is of the form::

    <ros-package-name> <relative-file-path>

For example::

    rosconsole ros_comm/tools/rosconsole

To locate a package-relative executable when the ``CATKIN_BINARY_DIR``
environment variable is set, tools use the following precedence:

 1. If an entry ``<ros-package-name> <relative-file-path>`` is in
    ``packages.list``, look for binary in
    ``$CATKIN_BINARY_DIR/<relative-file-path>``
 2. If executable is not found yet, look for the executable in the ROS package directory.

This implementation assumes that the underlying build system, catkin,
properly separates executables into separate directories based on ROS
package name to prevent collisions.

This portion of the specification is potentially volatile, as it
depends on a implementation that has not been reviewed yet.

``<catkin>`` tag in manifest
----------------------------

Package manifests [3]_ can now contain a ``<catkin>`` tag, to indicate
that they are built using the catkin build system.  This tag is a
performance optimization for tools like ``rosmake`` and the Python
``roslib.load_manifest()`` API.

PYTHONPATH, roslib.load_manifest()
----------------------------------

Python modules now install into a ``dist-packages``/``site-packages``
directory in the install prefix.  This installation uses the standard
Python distutil/setuptools toolchain.

The Python install directory is added to the ``PYTHONPATH``.  Thus,
these modules are immediately accessible via Python ``import`` and do
not require a ``roslib.load_manifest()``.

In order to prevent unnecessary accumulation to the Python
``sys.path``, ``roslib.load_manifest()`` does not recurse through
packages that have a ``<catkin/>`` tag in their manifest.

Python modules and scripts that are part of the FHS install layout
*must not* use ``load_manifest`` as it does not work properly within
an out-of-source build.


Motivation
==========

The ROS Fuerte release migrates many of the low-level libraries to use
a standard Filesystem Hiearchy Standard-like layout [2]_ contained in
a distribution-specific install prefix (e.g. ``/opt/ros/fuerte/``).

The goals of this conversion are many:

 - Make ROS libraries more "normal"

 - Enable the ROS toolchain to use existing libraries for packaging
   and release (e.g. ``git-buildpackage``)

 - Enable ROS messages, libraries and tools to be easily integrated
   with other build systems via ``pkg-config`` and CMake's
   ``find_package()``.

 - Enable ROS binary releases to be accepted into Debian, Ubuntu, and
   other Linux distributions.
   
 - Preserve the ability to install multiple ROS distributions on the
   same machine.

 - Eventually eliminate the need for ROS-specific filesystem
   environment variables when the installation is not in an install
   prefix.

The final goal should be possible with converted stacks, but has not
yet been verified.  The focus on the implementation has been
preserving the ability to install multiple ROS distributions on the
same machine as robots are frequently shared, expensive resources.
The feature enables newer releases to be easily adopted without
breaking existing code.

Compatibility with the Filesystem Hiearchy Standard has been a
long-term goal for ROS.  ROS began as an in-source, package-relative
system for finding, developing, building, and distributing code.
Multiple attempts have been made to transition towards an
FHS-compatible layout for ROS, including the withdrawn REP 102 [4]_
and a prototype "rosbuild2" system that was deployed in ROS Electric.

Experiences with those previous efforts have enabled us to accomplish
this goal with minimal compatibility issues.


Backwards Compatibility
=======================

/opt/ros/<distro>/stacks
------------------------

Legacy (rosmake-based) stacks still use the same installation
procedure as before.  We have been able to build legacy stacks on top
of the new FHS layout by following the ``share/<ros-package-name>``
layout described above.  We have not yet found any regressions related
to the new layout for building legacy stacks that are specifically
related to this specification.  We have put together a migration guide
[4]_ that generally notes issues with increased link/include
strictness.

rosmake
-------

rosmake will recurse into packages that are installed in ``share``.
As this location does not contain ``Makefile`` files, it will treat
this as not buildable.  For small performance improvements, new-style
packages with a ``<catkin>`` tag in their manifest.xml are treated the
same as ``ROS_NOBUILD``.

roslaunch remote, <machine> tag incompatibility
-----------------------------------------------

The changes in this specification break compatibility with roslaunch
remote launches.  The non-backwards-compatible changes required in
roslaunch are specified separately in REP 124 [5]_.

Stack dependencies, roscreate-stack
-----------------------------------

The new install layout does not preserve the stack-package
relationship: it is no longer possible to determine the packages that
a stack contains in the install layout.

To the best of our knowledge, the only tool affected by this is
``roscreate-stack``.  Although this is a convenient tool, it has less
utility moving forward, so we made the difficult decision to delete
it.

We considered attempting to preserve this information, but we viewed
this as wasted effort.  The implementation of the new build system
leverages the fact that all converted ROS stacks are just system
dependencies.  A dependency on 'boost' is no different than a
dependency on 'ros_comm'. These system system dependencies are
resolved using tools like rosdep.  This seamlessness is necessary as
the intent of this REP is to treat the converted stacks as
"standalone" libraries that can be easily integrated in other systems.

In other words, preserving the ``roscreate-stack`` tool would
implement the wrong behavior for converted stacks: it would treat them
as ROS stack dependencies, instead of system dependencies.


ROS_ROOT
--------

As described in the specification, ``ROS_ROOT`` preserves
backwards-compatibility for ``mk`` and ``rosbuild`` files.  For
example,

    include($ENV{ROS_ROOT}/core/rosbuild/rosbuild.cmake)

resolves to the same path.

roslib.load_manifest()
----------------------

The Python environment bootstrapper, ``roslib.load_manifest()``, is
safe to use in rosmake-based packages.  However, it is also
unnecessary for importing Python modules that use the FHS install
layout.


References
==========

.. [1] ROS filesystem environment variables
   (http://ros.org/doc/api/rospkg/html/environment.html) 
.. [2] Wikipedia: Filesystem Hiearchy Standard
   (http://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard)
.. [3] ROS Manifest XML Tags Reference
   (http://www.ros.org/doc/api/rospkg/html/manifest_xml.html)
.. [4] REP 102: ROS Install Target
   (http://ros.org/reps/rep-0102.html) 
.. [5] ROS Fuerte Migration Guide
   (http://ros.org/wiki/fuerte/Migration)
.. [6] REP 124: Changes to roslaunch and rosrun for new filesystem layout and catkin build system
   (http://ros.org/reps/rep-0124.html) 


Copyright
=========

This document has been placed in the public domain.



..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:

