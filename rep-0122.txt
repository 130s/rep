REP: 122
Title: Filesystem Hierarchy Standard layout changes for ROS
Version: $Revision: 1 $
Last-Modified: $Date: 2012-02-06 13:00:00 +0200 (Mon, 6 Feb 2012) $
Author: Ken Conley
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 6-Feb-2012
ROS-Version: Fuerte
Post-History: 6-Feb-2012

Abstract
========

This REP introduces a new Filesystem Hierarchy Standard (FHS) [1]_
layout for ROS and discusses the implications and changes necessary
for ROS code that is converted to this standard.  

For ROS distributions, such as ROS Fuerte, this layout is created
within an install prefix, but this specification is intended to make
non-prefixed installs possible as well.

This REP makes reference to the catkin build system, which is used as
our reference implementation. However, this REP does not provide
catkin-specific documentation an is intended to mostly be neutral to
implementation. 


Specification
=============

This specification defines changes to the filesystem layout,
associated environment variable changes, as well as changes necessary
within the ROS toolchain.

For the most part, this specification avoids a specific reliance on
the catkin build system except for:

 - locating binary executables in a catkin build workspace
 - a new manifest tag to mark packages as being built by catkin

Additionally, this specification does not define catkin-specific
additions, such as modifications to ``CMAKE_PREFIX_PATH`` and
``etc/catkin``.


Filesystem layout
'''''''''''''''''

Install prefix
--------------

For clarity, the install prefix is referred to as
``/opt/ros/<distro>``. The install prefix does not have to follow this
actual pattern, but it is the convention that ROS binary distributions
follow.

The intent of this layout is to enable installations with no install
prefix whatsoever, though this is not possible at the time of this
REP.

Directory layout
----------------

The layout within the ``/opt/ros/<distro>`` install prefix is::

    bin/
    etc/
    include/
    lib/
    share/
    stacks/


This layout generally follows FHS conventions, with the addition of
the ``stacks`` directory for legacy (backwards-compatible) installs.
It also contains setup files to easily configure environment variables
for this prefix.

For backwards-compatibility, existing packages and stacks use the
following pattern::

    share/<ros-stack-name>/stack.xml
    share/<ros-package-name>/manifest.xml

Stacks should *never* install to both ``share`` and ``stacks``.
Stacks following this specification install to ``share``.  Legacy
(rosmake-based) stacks install to ``stacks``.

These directories are described in greater detail below.


bin/
----

``bin`` is used to store top-level executables, i.e. executables that
are on ``PATH``.  This location replaces the old ``ROS_ROOT/bin``
location that stored ROS binaries, like ``rostopic`` and ``rospack``.

ROS stacks that are converted to use this new layout may install into
``bin``, but should do so sparingly as it adds to the user's ``PATH``.
Developers should also be careful about top-level executables and name
collisions.  In general, try to name executables so that the origin of
the executable is obvious, e.g. the same as the ROS package name.

In the case of an install prefix, ``PATH`` must include this location, e.g.::

    PATH=/opt/ros/<distro>/bin

etc/
----

This location is used to install global configuration files for a
particular ROS distribution.  Within the context of ROS, we introduce
``etc/ros``, which is where ROS-specific system configuration files
are stored.

Additionally, there is an ``etc/catkin`` and ``etc/langs`` that are
used by the underlying catkin build system.  Although ``etc/langs``
configures the active ROS message generators, it's implementation is
specific to message generation using catkin, and thus not specified
here.


include/
--------

ROS packages using the new install layout must install all header
files to the ``include`` directory.  Assuming a ROS package uses the
namespace ``<ros-package-name>``, include files for a package are
stored in::

    include/<ros-package-name>/

The specific include directories for a package are located using
``pkg-config`` or CMake ``find_package()``.


lib/
----

ROS packages using the new install layout must install all header
files to the ``lib`` directory.  

Python modules are installed ``lib/pythonX.Y``, where ``X.Y`` is the
Python version.  This directory follows the standard Python
specification for the target platform.  Thus, it may be
``lib/pythonX.Y/dist-packages`` or ``lib/pythonX.Y/site-packages`` or
otherwise.

In the case of an install prefix, ``PKG_CONFIG_PATH`` must be set to
enable locating libraries and include directories using
``pkg-config``.  ``LD_LIBRARY_PATH`` must be also set so that
executables can load shared libraries.  We use the settings::

    PKG_CONFIG_PATH=/opt/ros/<distro>/lib/pkgconfig::$PKG_CONFIG_PATH
    LD_LIBRARY_PATH=/opt/ros/<distro>/lib:$LD_LIBRARY_PATH

``PYTHONPATH`` must also be set in an install prefix as is platform
dependent.  For example, on Ubuntu Lucid with Python 2.6, the setting
is::

    PYTHONPATH=/opt/ros/<distro>/python2.6/dist-packages:$PYTHONPATH


share/
------

``share`` is the root of the ``ROS_PACKAGE_PATH``.

All package-relative assets must be explicitly installed to
``share/<ros-package-name>``.  These assets include:

 * manifest files (``manifest.xml``)
 * launch files
 * package-relative-executables (both binary and script)
 * bag files used in a package-relative manner

By convention, binary executables go in
``share/<ros-package-name>/bin`` and script executables go in
``share/<ros-package-name/scripts``.  This convention is not enforced.

Similarly, all stack-relative assets must be explicitly
installed to ``share/<ros-stack-name``.  These assets include:

 * manifest files (``stack.xml``)
 * rosdep definitions (``rosdep.yaml``)  (See note below)

NOTE: rosdep is currently being redesigned to make stack-relative
``rosdep.yaml`` files unnecessary.  ``rosdep.yaml`` files are expected
to disappear from the ``share`` directory once this new functionality
is available.


stacks/
-------

``stacks`` is installation location for legacy, rosmake-based stacks.
It is included on the ``ROS_PACKAGE_PATH``, but has lower precedence
than ``share``.


Environment variables
'''''''''''''''''''''

The new layout requires changes to existing ROS filesystem environment
variables [2]_.  Separately, REP 123 [9]_ proposes new ROS filesystem
environment variables to leverage the FHS layout more effectively.


``ROS_ROOT``
------------

``ROS_ROOT`` is defined to be::

    ROS_ROOT=/opt/ros/<distro>/share/ros

The *only* purpose of ``ROS_ROOT`` is backwards compatibility for
finding legacy ``rosbuild`` and ``mk`` resources.  It no longer
contains ROS binaries nor any other ROS stack assets.


``ROS_PACKAGE_PATH``
--------------------

``ROS_PACKAGE_PATH`` is defined to be::

    ROS_PACKAGE_PATH=/opt/ros/<distro>/share:/opt/ros/<distro>/stacks

Thus, ``share/`` has precedence over ``stacks/``.  

Packages and stacks are responsible for explicitly installing
``manifest.xml`` and ``stack.xml`` files in
``share/<package-or-stack-name>``.

Changes to ROS
''''''''''''''

``<catkin>`` tag in manifest
----------------------------

Package manifests [3]_ can now contain a ``<catkin>`` tag, to indicate
that they are built using the catkin build system.  This tag is a
performance optimization for tools like ``rosmake`` and the Python
``roslib.load_manifest()`` API.

PYTHONPATH, roslib.load_manifest()
----------------------------------

Python modules now install into a ``dist-packages``/``site-packages``
directory in the install prefix.  This installation uses the standard
Python distutil/setuptools toolchain.

The Python install directory is added to the ``PYTHONPATH``.  Thus,
these modules are immediately accessible via Python ``import`` and do
not require a ``roslib.load_manifest()``.

In order to prevent unnecessary accumulation to the Python
``sys.path``, ``roslib.load_manifest()`` does not recurse through
packages that have a ``<catkin/>`` tag in their manifest.

Python modules and scripts that are part of the FHS install layout
*must not* use ``load_manifest`` as it does not work properly within
an out-of-source build.

Stack version may now be in stack.yaml
--------------------------------------

Catkin defines a ``stack.yaml`` file for release packaging that
contains a version number.  In order to not violate DRY (Don't Repeat
Yourself) principles, tools like ``rosversion`` are now capable of
locating the version number defined in this file.  This REP amends REP
109 [4]_ to specify that the version number in the ``stack.yaml`` has the
highest precedence.

Motivation
==========

The ROS Fuerte release migrates many of the low-level libraries to use
a standard Filesystem Hiearchy Standard-like layout [2]_ contained in
a distribution-specific install prefix
(e.g. ``/opt/ros/fuerte/``). The goals of this conversion are many:

 - Make ROS libraries more "normal"

 - Enable the ROS toolchain to use existing libraries for packaging
   and release (e.g. ``git-buildpackage``)

 - Enable ROS messages, libraries and tools to be easily integrated
   with other build systems via ``pkg-config`` and CMake's
   ``find_package()``.

 - Enable ROS binary releases to be accepted into Debian, Ubuntu, and
   other Linux distributions.
   
 - Preserve the ability to install multiple ROS distributions on the
   same machine.

 - Eventually eliminate the need for ROS-specific filesystem
   environment variables when the installation is not in an install
   prefix.

The final goal should be possible with converted stacks, but has not
yet been verified.  There are also unresolved performance issues
discussed in the "Rationale" section.  The focus on the implementation
has been preserving the ability to install multiple ROS distributions
on the same machine as robots are frequently shared, expensive
resources.  

Compatibility with the Filesystem Hiearchy Standard has been a
long-term goal for ROS.  ROS began as an in-source, package-relative
system for finding, developing, building, and distributing code.
Multiple attempts have been made to transition towards an
FHS-compatible layout for ROS, including the withdrawn REP 102 [5]_
and a prototype "rosbuild2" system that was deployed in ROS Electric.
Experiences with those previous efforts have enabled us to accomplish
this goal with minimal compatibility issues.

One major goal these changes have enabled is much better integration
with PCL.  The standalone version of PCL can now build against the
required ROS messages with minimal additional dependencies.  In fact,
it does not even require use of the catkin build system.  Hopefully,
many more libraries will be able to transition to standalone
implementations.


Rationale
=========

The rationale for using the Filesystem Hierarchy Standard is simple:
it is the only solution for making the system more "normal".  Most of
the specifications in this REP are straightforward translations of
that standard, with the only exception being the use of ``share``.

This REP adds ``share`` to the ``ROS_PACKAGE_PATH``.  ``share`` is
intended for "read-only architecture independent data files" [8]_.
This is not true for this REP as package-relative binaries are
installed to this directory. Furthermore, there are unresolved
performance issues with this choice if an installation prefix is not
used.

All directories in this directory will be traversed by tools like
``rospack`` and ``rosstack``.  This is efficient if all
sub-directories are ROS aware, but will deteriorate greatly if the
presence of deep, non-ROS aware directories.

There are multiple ways to address this issue by updating the ROS
package and stack specification.  For example, a lookup table could be
used instead for installed packages.  Package-relative computations
could also be made much more simple as the location relative to
``share`` is fixed.

This REP does not attempt to resolve this issue.  Instead, more
experience working within this new layout will hopefully provide
better intuition on how to complete this transition.

Backwards Compatibility
=======================

/opt/ros/<distro>/stacks
------------------------

Legacy (rosmake-based) stacks still use the same installation
procedure as before.  We have been able to build legacy stacks on top
of the new FHS layout by following the ``share/<ros-package-name>``
layout described above.  There are no known regressions related to the
new layout for building legacy stacks that are specifically related to
this specification.  We have put together a migration guide [6]_ that
generally notes issues with increased link/include strictness.

rosmake
-------

rosmake will recurse into packages that are installed in ``share``.
As this location does not contain ``Makefile`` files, it will treat
this as not buildable.  For small performance improvements, new-style
packages with a ``<catkin>`` tag in their manifest.xml are treated the
same as ``ROS_NOBUILD``.

roslaunch remote, <machine> tag incompatibility
-----------------------------------------------

The changes in this specification break compatibility with roslaunch
remote launches.  The non-backwards-compatible changes required in
roslaunch are specified separately in REP 124 [7]_.

Stack dependencies, roscreate-stack
-----------------------------------

The new install layout does not preserve the stack-package
relationship: it is no longer possible to determine the packages that
a stack contains in the install layout.

To the best of our knowledge, the only tool affected by this is
``roscreate-stack``.  Although this is a convenient tool, it has less
utility moving forward, so we made the difficult decision to delete
it.

There are alternatives that preserve this information, but it would
waste effort.  The implementation of the new build system leverages
the fact that all converted ROS stacks are normal system dependencies,
e.g., a dependency on "boost" is no different than a dependency on
"ros_comm". These system system dependencies are resolved using tools
like rosdep.  This seamlessness is necessary as the intent of this REP
is to treat the converted stacks as "standalone" libraries that can be
easily integrated in other systems.

In other words, preserving the ``roscreate-stack`` tool would
implement the wrong behavior for converted stacks: it would treat them
as ROS stack dependencies, instead of system dependencies.


ROS_ROOT
--------

As described in the specification, ``ROS_ROOT`` preserves
backwards-compatibility for ``mk`` and ``rosbuild`` files.  For
example,

    include($ENV{ROS_ROOT}/core/rosbuild/rosbuild.cmake)

resolves to the same path.

roslib.load_manifest()
----------------------

The Python environment bootstrapper, ``roslib.load_manifest()``, is
safe to use in rosmake-based packages.  However, it is also
unnecessary for importing Python modules that use the FHS install
layout.

As noted in the specification, ``roslib.load_manifest()`` cannot be
used in converted stacks.


References
==========

.. [1] Wikipedia: Filesystem Hiearchy Standard
   (http://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard)
.. [2] ROS filesystem environment variables
   (http://ros.org/doc/api/rospkg/html/environment.html) 
.. [3] ROS Manifest XML Tags Reference
   (http://www.ros.org/doc/api/rospkg/html/manifest_xml.html)
.. [4] REP 109: Unary Stacks
   (http://ros.org/reps/rep-0109.html)
.. [5] REP 102: ROS Install Target
   (http://ros.org/reps/rep-0102.html) 
.. [6] ROS Fuerte Migration Guide
   (http://ros.org/wiki/fuerte/Migration)
.. [7] REP 124: Changes to roslaunch and rosrun for new filesystem layout and catkin build system
   (http://ros.org/reps/rep-0124.html) 
.. [8]: Filesystem Hierarchy Standard 2.3
   (http://www.pathname.com/fhs/pub/fhs-2.3.pdf)
.. [9]: REP 123: ROS_ETC_DIR, ROS_DISTRO environment variables and ROS_ROOT changes
   (http://ros.org/reps/rep-0123.html) 
Copyright
=========

This document has been placed in the public domain.



..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:

